{"version":3,"sources":["util.js","HighlightNode.js","FitnessMatrix.js","App.js","index.js"],"names":["alphabet","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22","23","24","25","26","27","28","29","30","31","32","33","34","35","36","37","38","39","40","41","42","43","44","45","46","47","48","49","50","51","52","53","54","55","56","57","58","alphabet_keys","Object","keys","alphabet_max","length","alphabet_min","Agent","set_goal","goal_state","split","goal_state_encoding","map","letter","letter_to_int","random_ints","i","push","Math","floor","random","initial_state_encoding","initial_state","integer","int_to_letter","get_successors","state","successors","j","successor","fitness","int_encoding","fitness_score","abs","key","int","Node","parent_one","parent_two","parent_split_point","is_mutated","value","generation","mutation_point","this","id","uuid","HighlightNode","node","join","slice","concat","FitnessMatrix","history","currentHighlightNode","updateHighlightNode","fitness_worst_score","getStyles","style","width","height","backgroundColor","borderCollapse","marginTop","display","className","border","_","colIndex","row","gen","onClick","App","useState","input","setInput","agentReady","setAgentReady","agentGoal","setAgentGoal","solution","setSolution","setHistory","setCurrentHighlightNode","highlightNode","node_generation","find","onSubmit","event","preventDefault","type","pattern","onChange","target","maxLength","e","agent","population","step_limit","select_parents","population_nodes","worst_fitness_score","softmax_scores","f","exp","softmax_sum","reduce","a","b","weights","s","cum_weights","running_total","random_float_one","parent_one_index","findIndex","w","random_float_two","parent_two_index","reproduce","parent_nodes","parent_state_one","parent_state_two","split_point","child_state","parent_generation","mutate","node_state","random_int","random_letter","ceil","step","mutation_epsilon","p","population_fitness","population_history","includes","next_population_nodes","child_node","mutation","copy","sort","solution_node","genetic_algorithm","idx","gen_copy","elite","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.6e5d88d1.chunk.js","sourcesContent":["import { v4 as uuid } from 'uuid';\r\n\r\nexport const alphabet = {\r\n    1: 'a', 2: 'A',\r\n    3: 'b', 4: 'B',\r\n    5: 'c', 6: 'C',\r\n    7: 'd', 8: 'D',\r\n    9: 'e', 10: 'E',\r\n    11: 'f', 12: 'F',\r\n    13: 'g', 14: 'G',\r\n    15: 'h', 16: 'H',\r\n    17: 'i', 18: 'I',\r\n    19: 'j', 20: 'J',\r\n    21: 'k', 22: 'K',\r\n    23: 'l', 24: 'L',\r\n    25: 'm', 26: 'M',\r\n    27: 'n', 28: 'N',\r\n    29: 'o', 30: 'O',\r\n    31: 'p', 32: 'P',\r\n    33: 'q', 34: 'Q',\r\n    35: 'r', 36: 'R',\r\n    37: 's', 38: 'S',\r\n    39: 't', 40: 'T',\r\n    41: 'u', 42: 'U',\r\n    43: 'v', 44: 'V',\r\n    45: 'w', 46: 'W',\r\n    47: 'x', 48: 'X',\r\n    49: 'y', 50: 'Y',\r\n    51: 'z', 52: 'Z',\r\n    53: ' ', 54: '.',\r\n    55: ',', 56: '!',\r\n    57: '?', 58: '-',\r\n}\r\n\r\nconst alphabet_keys = Object.keys(alphabet)\r\n\r\nexport const alphabet_max = alphabet_keys[alphabet_keys.length - 1]\r\nexport const alphabet_min = alphabet_keys[0]\r\n\r\nexport class Agent {\r\n\r\n    set_goal = goal_state => {\r\n        this.goal_state = goal_state.split('');\r\n        this.goal_state_encoding = this.goal_state.map(letter => this.letter_to_int(letter))\r\n        const random_ints = []\r\n        for (let i = 0; i < this.goal_state.length; i++) {\r\n            random_ints.push(Math.floor(Math.random() * (alphabet_max - alphabet_min + 1) + 1))\r\n        }\r\n        this.initial_state_encoding = [...random_ints];\r\n        this.initial_state = this.initial_state_encoding.map(integer => this.int_to_letter(integer));\r\n\r\n        return this.goal_state\r\n    }\r\n\r\n    get_successors = state => {\r\n        const successors = []\r\n        for (let i = 0; i < state.length; i++) {\r\n            for (let j = alphabet_min; j < alphabet_max; j++) {\r\n                if (state[i] !== j) {\r\n                    const successor = [...state];\r\n                    successor[i] = this.int_to_letter(j);\r\n                    successors.push(successor)\r\n                }\r\n            }\r\n        }\r\n        return successors\r\n    }\r\n\r\n    fitness = state => {\r\n        const int_encoding = state.map(letter => this.letter_to_int(letter));\r\n        let fitness_score = 0;\r\n        for (let i = 0; i < int_encoding.length; i++) {\r\n            fitness_score += Math.abs(this.goal_state_encoding[i] - int_encoding[i]);\r\n        }\r\n        return fitness_score\r\n    }\r\n\r\n    letter_to_int = letter => {\r\n        for (let key in alphabet) {\r\n            if (alphabet[key] === letter) return key\r\n        }\r\n    }\r\n\r\n    int_to_letter = int => alphabet[int]\r\n}\r\n\r\nexport class Node {\r\n    constructor(state, parent_one, parent_two, parent_split_point, is_mutated, value, generation, mutation_point) {\r\n        this.id = uuid()\r\n        this.state = state\r\n        this.parent_one = parent_one\r\n        this.parent_two = parent_two\r\n        this.parent_split_point = parent_split_point\r\n        this.is_mutated = is_mutated\r\n        this.value = value\r\n        this.generation = generation\r\n        this.mutation_point = mutation_point\r\n    }\r\n}\r\n\r\nexport const genetic_algorithm = (population, fitness, step_limit=10) => {\r\n\r\n    const select_parents = population_nodes => {\r\n        const worst_fitness_score = (alphabet_max - alphabet_min) * population_nodes[0].state.length;\r\n        const fitness_scores = population_nodes.map(node => node.value);\r\n        const softmax_scores = fitness_scores.map(f => Math.exp(worst_fitness_score - f));\r\n        const softmax_sum = softmax_scores.reduce((a, b) => a + b, 0);\r\n        const weights = softmax_scores.map(s => s/softmax_sum);\r\n        const cum_weights = [];\r\n        let running_total = 0;\r\n        for (let i = 0; i < weights.length; i++) {\r\n            running_total += weights[i];\r\n            cum_weights.push(running_total);\r\n        }\r\n        const random_float_one = Math.random();\r\n        const parent_one_index = cum_weights.findIndex(w => random_float_one < w);\r\n        const random_float_two = Math.random();\r\n        const parent_two_index = cum_weights.findIndex(w => random_float_two < w);\r\n\r\n        return [population_nodes[parent_one_index], population_nodes[parent_two_index]];\r\n    }\r\n\r\n    const reproduce = parent_nodes => {\r\n        const parent_state_one = parent_nodes[0].state;\r\n        const parent_state_two = parent_nodes[1].state; \r\n        const split_point = Math.floor(Math.random() * parent_state_one.length);\r\n        const child_state = parent_state_one.slice(0,split_point).concat(parent_state_two.slice(split_point));\r\n        const parent_generation = parent_nodes[0].generation;\r\n        return new Node(child_state, parent_nodes[0], parent_nodes[1], split_point, false, fitness(child_state), parent_generation + 1, -1)\r\n    }\r\n\r\n    const mutate = node => {\r\n        const node_state = [...node.state];\r\n        const random_int = Math.floor(Math.random() * node_state.length);\r\n        const random_letter = alphabet[Math.ceil(Math.random() * alphabet_max)];\r\n        node_state[random_int] = random_letter\r\n        return new Node(\r\n            node_state, \r\n            node.parent_one, \r\n            node.parent_two, \r\n            node.parent_split_point, \r\n            true, \r\n            fitness(node_state), \r\n            node.generation,\r\n            random_int)\r\n    }\r\n\r\n\r\n    let step = 0;\r\n    const mutation_epsilon = 0.1;\r\n\r\n    let population_nodes = population.map(p => new Node(p, null, null, null, false, fitness(p), 1, -1));\r\n    let population_fitness = population_nodes.map(p => p.value);\r\n    const population_history = [population_nodes];\r\n\r\n    while (!population_fitness.includes(0) && (step < step_limit)) {\r\n\r\n        // if (step % 1 === 0) console.log(`Generation ${step} --> ${population_nodes[0].state} (${population_nodes[0].value})`);\r\n\r\n        let next_population_nodes = []\r\n\r\n        for (let i = 0; i < population_nodes.length; i++) {\r\n            let parent_nodes = select_parents(population_nodes);\r\n            let child_node = reproduce(parent_nodes);\r\n            let mutation = Math.random();\r\n            if (mutation < mutation_epsilon) {\r\n                child_node = mutate(child_node);    \r\n            }\r\n            next_population_nodes.push(child_node);\r\n        }\r\n\r\n        population_nodes = next_population_nodes;\r\n        population_fitness = population_nodes.map(p => p.value);\r\n        population_history.push(population_nodes);\r\n\r\n        step += 1;\r\n    }\r\n\r\n    const copy = [...population_nodes]\r\n    copy.sort((a, b) => a.value - b.value)\r\n    const solution_node = copy[0]\r\n\r\n    return {\r\n        solution: solution_node,\r\n        step: step,\r\n        history: population_history\r\n    }\r\n\r\n} \r\n\r\nexport const get_ancestors = youngest_node => {\r\n    const recurse = node => {\r\n        if (!node.parent_one) {\r\n            return []\r\n        } else {\r\n            return [node.parent_one, node.parent_two].concat(recurse(node.parent_one)).concat(recurse(node.parent_two));\r\n        }\r\n    }\r\n    return recurse(youngest_node)\r\n}\r\n\r\nexport const get_tree_repr = (node, limit) => {\r\n    if (!node.parent_one || !limit) {\r\n        return { \r\n            id: node.id,\r\n            name: `${node.state.join('')} (${node.value})`\r\n        }\r\n    } else {\r\n        return {\r\n        id: node.id,\r\n        name: `${node.state.join('')} (${node.value})`,\r\n        children: [node.parent_one, node.parent_two].map(n => get_tree_repr(n, limit - 1))\r\n        }\r\n    }\r\n}","import React from 'react';\r\n\r\nfunction HighlightNode({ node }) {\r\n\r\n    return (\r\n        <>\r\n            <h3>Node Information</h3>\r\n            <p>Generation: {node.generation}</p>\r\n            <p>String: [{node.state.join('')}]</p>\r\n            <p>Fitness: {node.value}</p>\r\n            <p>\r\n                Immediate parents: {\r\n                node.generation !== 1 ? \r\n                `[${node.parent_one.state.join('')}] ⨉ [${node.parent_two.state.join('')}]` :\r\n                `None`}\r\n            </p>\r\n            <p>\r\n                Parent fitnesses: {\r\n                node.generation !== 1 ?\r\n                `${node.parent_one.value},  ${node.parent_two.value}` : \r\n                `None`}\r\n            </p>\r\n            <p>\r\n                Parent crossover point: {\r\n                node.generation !== 1 ?\r\n                `${node.parent_split_point} => [${node.parent_one.state.slice(0, node.parent_split_point).join('')}] + [${node.parent_two.state.slice(node.parent_split_point).join('')}]` :\r\n                `None`}\r\n            </p>\r\n            <p>\r\n                Is mutated: {node.is_mutated ? `Yes` : 'No'}\r\n            </p>\r\n            <p>\r\n                Mutation point: {node.is_mutated ? `${node.mutation_point} [${node.parent_one.state.slice(0, node.parent_split_point).concat(node.parent_two.state.slice(node.parent_split_point))[node.mutation_point]}] => [${node.state[node.mutation_point]}]` : ''}\r\n            </p>\r\n        </>\r\n    )\r\n}\r\n\r\nexport default HighlightNode;","import React from 'react';\r\nimport { alphabet_max, alphabet_min } from './util';\r\n\r\nfunction FitnessMatrix({ history, currentHighlightNode, updateHighlightNode }) {\r\n\r\n    const fitness_worst_score = (alphabet_max - alphabet_min) * history[0][0].state.length;\r\n    const getStyles = node => {\r\n        const style= {\r\n            width: '7px', \r\n            height: '7px',\r\n            backgroundColor: `rgba(0, 0, 0, ${node.value ** 2/ fitness_worst_score})`,\r\n            borderCollapse: 'collapse'\r\n        }\r\n\r\n        if (currentHighlightNode.id === node.id) {\r\n            style.backgroundColor = 'red';\r\n        } \r\n        \r\n        if (currentHighlightNode.generation !== 1) {\r\n            if (currentHighlightNode.parent_one.id === node.id || currentHighlightNode.parent_two.id === node.id) {\r\n                style.backgroundColor = 'orange';\r\n            }\r\n        }\r\n\r\n        return style\r\n    }\r\n\r\n    return (\r\n        <>\r\n            <h3 style={{ marginTop: '10px' }}>Fitness Matrix</h3>\r\n            <p>Horizontal axis denotes generation (left side of matrix shows earlier generations)</p>\r\n            <p>Vertical axis denotes individuals (nodes within the same column are from the same generation)</p>\r\n            <p>Lighter color denotes higher fitness score</p>\r\n            <p><div style={{ height: '7px', width: '7px', backgroundColor: 'red', display: 'inline-block' }}></div> denotes currently selected node</p>\r\n            <p><div style={{ height: '7px', width: '7px', backgroundColor: 'orange', display: 'inline-block' }}></div> denotes parents of currently selected node</p>\r\n            <div className=\"fitness-matrix\" style={{ border: '1px solid black', display: 'inline-block' }}>\r\n                {history[0].map((_, colIndex) => history.map(row => row[colIndex])).map(gen => (\r\n                    <div className=\"row\" style={{ display: 'flex' }}>\r\n                        {gen.map(node => <div className=\"node\" onClick={() => updateHighlightNode(node.id, node.generation)} style={getStyles(node)}></div>)}\r\n                    </div>\r\n                ))}\r\n            </div>\r\n        </>\r\n    )\r\n}\r\n\r\nexport default FitnessMatrix;","import React, { useState } from 'react';\r\nimport { Agent, genetic_algorithm, get_ancestors } from './util';\r\nimport HighlightNode from './HighlightNode';\r\nimport FitnessMatrix from './FitnessMatrix';\r\nimport './App.css';\r\n\r\nfunction App() {\r\n\r\n  const CHAR_LIMIT = 12;\r\n\r\n  const [input, setInput] = useState('');\r\n  const [agentReady, setAgentReady] = useState(false);\r\n  const [agentGoal, setAgentGoal] = useState('');\r\n  const [solution, setSolution] = useState(null);\r\n  const [history, setHistory] = useState(null);\r\n  const [currentHighlightNode, setCurrentHighlightNode] = useState(null);\r\n\r\n  const handleChange = event => setInput(event.target.value);\r\n\r\n  const handleSubmit = event => {\r\n    event.preventDefault();\r\n    setAgentGoal(input);\r\n    setAgentReady(true);\r\n    setInput('');\r\n    setSolution(null);\r\n    setHistory(null);\r\n  }\r\n\r\n  const runGenetic = e => {\r\n    const agent = new Agent();\r\n    agent.set_goal(agentGoal);\r\n    const initial_population = agent.get_successors(agent.initial_state);\r\n    const { solution, step, history } = genetic_algorithm(initial_population, agent.fitness, 100);\r\n    setSolution(solution);\r\n    setCurrentHighlightNode(solution);\r\n    setHistory(history);\r\n  }\r\n\r\n  const highlightNode = (id, node_generation) => {\r\n    const node = history[node_generation - 1].find(node => node.id === id);\r\n    setCurrentHighlightNode(node);\r\n  }\r\n\r\n  return (\r\n    \r\n    <div className=\"App\">\r\n      <div className=\"instructions\">\r\n        <h3>Word Searching with Genetic Algorithm</h3>\r\n        <p>\r\n          Starting from an initial \"population\" of randomly generated strings (of equal length to target \r\n          word), the algorithm searches for the target word by repeatedly generating new populations that \r\n          are increasingly fit with time. A string is fit if it is similar to the target word in terms of \r\n          the sum of the distances of the corresponding letters, according to the alphabet. For instance, \r\n          <i> a</i> is more similar to <i>c</i> than it is to <i>z</i>. \r\n        </p>\r\n        <br/>\r\n        <b>Algorithm.</b>\r\n        <p>\r\n          Repeat for <i>k</i> generations, or until the target word is found. Steps for producing each \r\n          population generation: \r\n        </p>\r\n        <ol>\r\n          <li>\r\n            Randomly select two individuals from the current generation, weighted by their fitness (fitter \r\n            individuals are more likely to be selected). These are the parents.\r\n          </li>\r\n          <li>\r\n            Split both parents based on a randomly determined split point. Then, combine the left half \r\n            of parent A with the right half of parent B, yielding the child. \r\n          </li>\r\n          <li>\r\n            Randomly mutate the child based on some independent probability. To mutate a child, replace \r\n            one symbol of the child with another randomly selected symbol. \r\n          </li>\r\n          <li>\r\n            Add child to the current generation pool. Repeat steps 1 - 3 until new population count reaches \r\n            the previous population count.\r\n          </li>\r\n        </ol>\r\n        <br/>\r\n        <form onSubmit={handleSubmit}>\r\n          <label>\r\n            Target word (max {CHAR_LIMIT} chars, chars allowed: <code>aZ., -?!</code>): \r\n            <input type=\"text\" value={input} pattern=\"[A-Za-z .,!?-]*\" onChange={handleChange} maxLength={CHAR_LIMIT}/>\r\n          </label>\r\n          <input type=\"submit\" value=\"Submit\"/>\r\n        </form>\r\n      </div>\r\n\r\n      {agentReady && \r\n      <>\r\n        <br/>\r\n        <p>Agent ready (Goal: <code>{agentGoal}</code>)</p>\r\n        <button onClick={runGenetic}>Run genetic algorithm</button>\r\n        <br />\r\n      </>}\r\n\r\n      {solution && history &&  \r\n        <div className=\"results\">\r\n          <div>\r\n            <b>\r\n            <p>{`Best fit solution found in generation ${history.length} (fitness score: ${solution.value})`}</p>\r\n            <p>{`Immediate parents: [${solution.parent_one.state.join('')}] and [${solution.parent_two.state.join('')}] (with mutation: ${solution.is_mutated})`}</p>\r\n            </b>\r\n            <br/>\r\n            <h3>Genetic history</h3>\r\n            <i>Click on table entry to show more information.</i>\r\n            <table>\r\n              <thead>\r\n                <tr>\r\n                  <th>Generation count</th>\r\n                  <th>Generation elite (fitness score)</th>\r\n                  <th>Parent 1</th>\r\n                  <th>Parent 2</th>\r\n                  <th>Mutated</th>\r\n                </tr>\r\n              </thead>\r\n              <tbody>\r\n                {history.map((gen, idx) => {\r\n                  const gen_copy = [...gen];\r\n                  gen_copy.sort((a, b) => a.value - b.value);\r\n                  const elite = gen_copy[0];\r\n                  return (\r\n                    <tr key={idx}>\r\n                      <th>{idx + 1}</th>\r\n                      <th onClick={() => highlightNode(elite.id, elite.generation)}>{`${elite.state.join('')} (${elite.value})`}</th>\r\n                      {idx !== 0 ? \r\n                        <th onClick={() => highlightNode(elite.parent_one.id, elite.parent_one.generation)}>{`${elite.parent_one.state.join('')} (${elite.parent_one.value})`}</th> : \r\n                        <th>{`None`}</th>}\r\n                      {idx !== 0 ? \r\n                        <th onClick={() => highlightNode(elite.parent_two.id, elite.parent_two.generation)}>{`${elite.parent_two.state.join('')} (${elite.parent_two.value})`}</th> : \r\n                        <th>{`None`}</th>}\r\n                      <th>{`${elite.is_mutated}`}</th>\r\n                    </tr>\r\n                  )\r\n                })}\r\n              </tbody>\r\n            </table>\r\n          </div>\r\n          <div className=\"highlight\">\r\n            <HighlightNode node={currentHighlightNode} />\r\n            <FitnessMatrix history={history} currentHighlightNode={currentHighlightNode} updateHighlightNode={highlightNode}/>\r\n          </div>\r\n        </div>}\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport App from './App';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);"],"sourceRoot":""}